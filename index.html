<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bingo Login & Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

  <style>
    body, html {
      height: 100%;
      margin-bottom: 10vh;
      font-family: sans-serif;
      display: flex;
      justify-content: center; 
      align-items: center;
      background: #fafafa;
      padding: 0%;
      overflow-x: hidden;
    }
    @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
    }
    .container {
      display: flex;
      gap: 40px;
      align-items: flex-start;
      max-width: 100%;
      flex-wrap: wrap;
    }

    .sidebar, .leaderboard {
      width: 160px;
      flex-shrink: 0;
      font-size: 3vmin;
    }

    .team-header {
      font-weight: bold;
      text-decoration: underline;
      margin-bottom: 6px;
    }

    .team-member {
      margin-left: 10px;
      margin-bottom: 4px;
      user-select: none;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(5, 1fr); /* Adjust based on your bingo size */
      aspect-ratio: 1 / 1;
      gap: 10px;
      max-width: 90vw;
      width: 90vmin; /* Ensures square shape */
      background: white;
      border: 2px solid #555;
      border-radius: 12px;
      padding: 10px;
      justify-content: center;
      user-select: none;
    }


    .cell {
      aspect-ratio: 1 / 1;
      background: #f0f0f0; 
      border: 2px solid #555;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2em;
      cursor: pointer;
      transition: background-color 0.3s ease, color 0.3s ease;
      position: relative;
      text-align: center;
      padding: 1%;
    }
    .cell-title {
      font-size: clamp(10px, 3vmin, 24px); /* scales but won’t get too big or too small */
      /* overflow-wrap: break-word;            wrap long words */
      /* white-space: normal; */
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: black; /* main text color */
      text-shadow:
        -0.75px -0.75px 0 white,
        0.75px -0.75px 0 white,
        -0.75px  0.75px 0 white,
        0.75px  0.75px 0 white;
    }


    .cell .claimed-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      border-radius: 8px;
    }

    .cell .claimed-layer {
      position: absolute;
      border-radius: 4px;
      box-sizing: border-box;
    }

    .cell:hover {
      background-color: #ddd;
    }

    .cell .media-indicator {
      position: absolute;
      bottom: 6px;
      right: 6px;
      width: 16px;
      height: 16px;
      background: url('data:image/svg+xml;utf8,<svg fill="black" height="16" width="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l11-7z"/></svg>') no-repeat center center;
      background-size: contain;
      opacity: 0.7;
    }

    form > input, form > button {
      font-size: 1em;
      padding: 6px;
      margin-top: 6px;
      width: 100%;
      box-sizing: border-box;
    }

    .error-message {
      color: red;
      margin-bottom: 12px;
      user-select: none;
    }

    .modal-overlay {
      position: fixed;
      aspect-ratio: 1/1;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.3s ease forwards;
      z-index: 999;
    }

    .modal-content {
      background: white;
      aspect-ratio: 1/1;
      border-radius: 8px;
      max-width: 80%;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      animation: fadeInScale 0.3s ease-in-out;
      position: relative; /* ✅ ensures the X stays in the right place */
    }


    @keyframes fadeIn {
      to { opacity: 1; }
    }

    @keyframes fadeInScale {
      from {
        transform: scale(0.9);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    @media (max-width: 768px) {
      body, html {
        align-items: flex-start;
        padding-top: 20px;
      }

      .container {
        flex-direction: column;
        align-items: center;
        gap: 20px;
        width: 100%;
        padding: 0 10px;
      }

      .board {
        max-width: 95%;
      }

      .sidebar, .leaderboard {
        width: 95%;
        text-align: center;
        font-size: 3vmin;
      }

      .team-member {
        margin-left: 0;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    const e = React.createElement;
    const socket = io("https://tunnel.bingogame.gay", {
      withCredentials: true,
      transports: ['websocket'],
    });

    function getCookie(name) {
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${name}=`);
      if (parts.length === 2) return parts.pop().split(';').shift();
      return null;
    }

    function setCookie(name, value, days = 1) {
      const expires = new Date(Date.now() + days * 864e5).toUTCString();
      document.cookie = `${name}=${value}; path=/; expires=${expires}`;
    }

    function App() {
      const [user, setUser] = React.useState(getCookie("username"));
      const [username, setUsername] = React.useState("");
      const [password, setPassword] = React.useState("");
      const [error, setError] = React.useState("");
      const [gameState, setGameState] = React.useState(null);
      const [teamNumber, setTeamNumber] = React.useState(null);
      const [modalVisible, setModalVisible] = React.useState(false);
      const [modalContent, setModalContent] = React.useState(null);
      const [quantity, setQuantity] = React.useState("");
      const [quantityError, setQuantityError] = React.useState(false);
      const [comment, setComment] = React.useState("");
      const [media, setMedia] = React.useState([]); 
      const [uploading, setUploading] = React.useState(false);
      
      function handleFileChange(e) {
        setMedia(Array.from(e.target.files || [])); // converts FileList -> array
      }

      function handleSave() {
        const formData = new FormData();
        usersName = getCookie("username")
        formData.append("team", teamNumber);
        formData.append("spot", modalContent.square);
        formData.append("game_id", gameState?.game_id);
        formData.append("user", user);
        formData.append("quantity", quantity);
        formData.append("comment", comment);
        media.forEach((file, idx) => {
          formData.append("file", file); // could also do `file${idx}` if you want multiple
        });
        setUploading(true);

        fetch("https://tunnel.bingogame.gay/upload", {
          method: "POST",
          body: formData
        })
        .then(res => res.json())
        .then(data => {
          console.log("Upload success:", data);
          setUploading(false);
        })
        .catch(err => {
          console.error("Upload error:", err);
          setUploading(false);
        });
      }

      function Countdown({ start_time, end_time }) {
        const [remaining, setRemaining] = React.useState(0);

        React.useEffect(() => {
          if (!start_time || !end_time) return;

          const start = new Date(start_time);
          const end = new Date(end_time);

          function updateCountdown() {
            const now = new Date();

            if (now < start) {
              // Before game starts — show total duration
              setRemaining(end - start);
            } else if (now >= start && now <= end) {
              // Game in progress — show remaining time until end
              setRemaining(end - now);
            } else {
              // After end
              setRemaining(0);
            }
          }

          updateCountdown();
          const interval = setInterval(updateCountdown, 1000);
          return () => clearInterval(interval);
        }, [start_time, end_time]);

        function format(ms) {
          if (ms <= 0) return "00:00:00";
          const totalSeconds = Math.floor(ms / 1000);
          const h = String(Math.floor(totalSeconds / 3600)).padStart(2, "0");
          const m = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, "0");
          const s = String(totalSeconds % 60).padStart(2, "0");
          return `${h}:${m}:${s}`;
        }

        return e("div", { style: { fontSize: "2.5rem", marginTop: "10px" , marginBottom: "10px"} }, format(remaining));
      }

      React.useEffect(() => {
        if (user) {
          fetch("https://tunnel.bingogame.gay/game_state", {
            credentials: "include"
          })
            .then(res => res.json())
            .then(data => {
              setGameState(data);
              for (const [teamNum, team] of Object.entries(data.teams || {})) {
                if (team.members.includes(user)) {
                  setTeamNumber((teamNum));
                  break;
                }
              }
            })
            .catch(() => setError("Failed to load game data"));
        }
      }, [user]);

      React.useEffect(() => {
        const handleGameUpdate = (data) => {
          setGameState(data);
        };

        socket.on("full_game_state", handleGameUpdate);

        return () => {
          socket.off("full_game_state", handleGameUpdate);
        };
      }, []);


      const handleLogin = async (e) => {
        e.preventDefault();
        setError("");
        try {
          const response = await fetch("https://tunnel.bingogame.gay/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify({ username, password }),
          });
          const data = await response.json();
          if (response.ok && data.success) {
            setCookie("username", username);
            setUser(username);
          } else {
            setError(data.error || "Login failed");
          }
        } catch (err) {
          setError(err);
        }
      };

      const handleClick = (row, col) => {
        if (!gameState) return;
        const index = row * gameState.grid_size + col;
        const cell = gameState.board[index];
        setModalContent(cell);
        setModalVisible(true);
      };

      const formatDateTime = (isoString) => {
        if (!isoString) return "N/A";
        const date = new Date(isoString);
        return date.toLocaleString("en-US", {
          month: "long",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "2-digit",
          second: "2-digit",
          hour12: true
        });
      };

      if (!user) {
        return e("div", { style: { maxWidth: 320 } }, [
          e("h2", null, "Login to Play Bingo"),
          error && e("div", { className: "error-message" }, error),
          e("form", { onSubmit: handleLogin }, [
            e("input", {
              type: "text",
              placeholder: "Username",
              value: username,
              onChange: (e) => setUsername(e.target.value),
              required: true
            }),
            e("input", {
              type: "password",
              placeholder: "Password",
              value: password,
              onChange: (e) => setPassword(e.target.value),
              required: true
            }),
            e("button", { type: "submit" }, "Login")
          ])
        ]);
      }

      if (!gameState) {
        return e("div", null, "Loading game...");
      }

      const teamInfo = gameState.teams?.[teamNumber] || { members: [], color: "black" };

      const board = [];
      for (let i = 0; i < gameState.board.length; i++) {
        const square = gameState.board[i];
        const row = Math.floor(i / gameState.grid_size);
        const col = i % gameState.grid_size;
        const claimed = square.claimed_by || [];
        const points = square.value || [];

        const layers = [];
        if (claimed.length > 0) {
          const shrinkPerLayer = 15; // percent shrink per layer
          const baseSize = 100;

          claimed.forEach((teamId, index) => {
            const team = gameState.teams[teamId];
            const color = team?.color || "gray";
            const size = baseSize - index * shrinkPerLayer;
            const offset = (100 - size) / 2;

            layers.push(e("div", {
              className: "claimed-layer",
              key: `layer-${index}`,
              style: {
                backgroundColor: color,
                width: `${size}%`,
                height: `${size}%`,
                top: `${offset}%`,
                left: `${offset}%`
              }
            }));
          });
        }

        board.push(
          e("div", {
            key: i,
            className: "cell",
            onClick: () => handleClick(row, col),
            style: { position: "relative", overflow: "hidden" }
          }, [
            e("div", { className: "claimed-overlay", style: { zIndex: 0 } }, layers),
            e("div", {
              className: "cell-title",
              style: {
                position: "relative",
                zIndex: 1,
                textAlign: "center",
                padding: "1vmin",
                fontWeight: "bold",
                color: "black", // or white, depending on background
                fontSize: "3vmin",          // or try 3cqw if your browser supports it
                maxWidth: "100%",
                maxHeight: "100%",
                lineHeight: "1.1",
                wordBreak: "break-word",    // wraps long words
                // overflow: "elipsis",         // prevents overflow
                whiteSpace: "normal",  
              }
            }, square.title || `Square ${i + 1}`),
            square.media?.length ? e("div", { className: "media-indicator", key: "media", style: { zIndex: 2 } }) : null
          ])
        );
      }
      const handleClaimSpot = async () => {
        try {
          if (modalContent.is_high_score_challenge === 1) {
            const parsedQuantity = parseInt(quantity);
            if (!parsedQuantity || parsedQuantity <= 0) {
              setQuantityError(true);
              return;
            }
            setQuantityError(false); // clear error if valid
          }
          const response = await fetch('https://tunnel.bingogame.gay/claim_spot', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({
              game_id: gameState?.game_id,
              spot: modalContent.square,
              team: teamNumber,
              media: null,
              quantity: modalContent.is_high_score_challenge === 1 ? parseInt(quantity) : 0,
              comment: "",
              user: user
            }),
          });
          
          const data = await response.json();
          if (response.ok && data.success) {
            console.log('Claim successful!');
            setModalVisible(false);
            // Optionally update state here if needed
          } else {
            alert('Error: ' + (data.error || 'Failed to claim spot'));
          }
        } catch (err) {
          console.error('Claim request failed', err);
        }
      };

      const leaderboard = Object.entries(gameState.teams || {})
        .map(([num, team]) => ({ team: num, score: team.score, color: team.color }))
        .sort((a, b) => b.score - a.score);

      return e("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", width: "100%" } }, [
        // Welcome
        e("div", {
          style: {
            marginBottom: "16px",
            fontSize: "1.4em",
            fontWeight: "bold",
            textAlign: "center"
          }
        }, [
          "Welcome, ",
          e("span", { style: { color: teamInfo.color } }, user)
        ]),

        // Layout container
        e("div", { className: "container" }, [

          // Sidebar
          e("div", { className: "sidebar" }, [
            e("div", { className: "team-header", style: { color: teamInfo.color } }, `Team ${teamNumber}`),
            ...teamInfo.members.map(name =>
              e("div", { className: "team-member", style: { color: teamInfo.color }, key: name }, name)
            )
          ]),

          // Board with modal inside
          e("div", {
            className: "board",
            style: { 
              gridTemplateColumns: `repeat(${gameState.grid_size}, 1fr)`,
              position: "relative" // Make board the positioning context for modal
            }
          }, [
            ...board,

            // Modal inside board
            modalVisible && modalContent && e("div", {
              className: "modal-overlay",
              style: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                backgroundColor: "rgba(0, 0, 0, 0.6)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                animation: "fadeIn 0.3s ease",
                zIndex: 10,
                pointerEvents: "auto"
              },
              onClick: () => setModalVisible(false)
            }, e("div", {
              className: "modal-content",
              style: {
                backgroundColor: "white",
                padding: "30px",
                borderRadius: "12px",
                width: "70%",
                height: "70%",
                overflowY: "auto",
                boxShadow: "0 4px 12px rgba(0, 0, 0, 0.3)",
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "flex-start",
                textAlign: "center"
              },
              onClick: e => e.stopPropagation()
            }, [
              e(
                "span",
                {
                  style: {
                    position: "absolute",
                    top: "2%",
                    right: "3%",
                    fontSize: "5vmin",
                    color: "gray",
                    cursor: "pointer",
                    fontWeight: "bold"
                  },
                  onClick: () => setModalVisible(false)
                },
                "×"
              ),
              e("h2", null, modalContent.title || "Untitled"),
              e("p", null, modalContent.description || "No description available."),
              modalContent.points?.length > 0 && e("p", null, `Points: ${modalContent.points[0]}`),
              e("p", { style: { marginTop: "10px", fontWeight: "bold" } }, "Teams Completed:"),
              e("div", { className: "modalleaderboard" }, 
                modalContent.claimed_by?.length > 0
                  ? modalContent.claimed_by.map((teamName, index) => {
                      const timestamp = modalContent.timestamps?.[index] || "unknown time";
                      const teamEntry = leaderboard.find(entry => entry.team === teamName);
                      const color = teamEntry?.color || "black";
                      const points = modalContent.value?.[index] ?? 0;
                      const scoreSuffix = modalContent.is_high_score_challenge == 1
                        ? `, score: ${modalContent.quantities?.[index] ?? "?"}`
                        : "";

                      return e(
                        "p",
                        { key: `${teamName}-${index}`, style: { margin: "4px 0", fontSize: "14px" } },
                        `#${index + 1} `,
                        e("span", { style: { color, fontWeight: "bold" } }, teamName),
                        ` ${timestamp} ${points} pts${scoreSuffix}`
                      );
                    })
                  : e("p", null, "None")
              ),
             !(modalContent.is_lockout_challenge === 1 && modalContent.claimed_by?.length > 0) &&
            (new Date() >= new Date(gameState.start_time) && new Date() <= new Date(gameState.end_time)) &&
            e("button", {
              style: { marginTop: "12px" },
              onClick: handleClaimSpot
            }, "Claim Spot"),
            (modalContent.is_high_score_challenge === 1) && e(React.Fragment, null, [
              e("input", {
                type: "number",
                placeholder: "Quantity",
                value: quantity,
                onChange: (e) => setQuantity(e.target.value),
                style: {
                  display: "block",
                  marginTop: "10px",
                  width: "100%",
                  borderColor: quantityError ? "red" : undefined
                }
              }),
              quantityError && e("div", {
                style: { color: "red", marginTop: "4px", fontSize: "0.9em" }
              }, "Must enter quantity")
            ]),
            // Show these only if the logged in team completed this spot
            (modalContent.claimed_by?.includes(teamNumber)) && e(React.Fragment, null, [
              e("input", {
                type: "file",
                style: { display: "none" },
                id: "mediaInput",
                multiple: true,
                onChange: handleFileChange
              }),
              e("button", {
                style: { marginTop: "12px" },
                onClick: () => document.getElementById("mediaInput").click()
              }, "Add Media"),

              // Preview area for selected files
              media.length > 0 && e("ul", {
                style: { marginTop: "8px", paddingLeft: "16px", fontSize: "0.9rem" }
              },
                media.map((file, idx) =>
                  e("li", { key: idx }, file.name)
                )
              ),

              e("textarea", {
                placeholder: "Comment (Optional)",
                rows: 1,
                value: comment,
                onChange: e => setComment(e.target.value),
                style: { display: "block", marginTop: "10px", width: "100%" }
              }),

              e("button", {
                style: { marginTop: "12px" },
                onClick: handleSave,
                disabled: uploading
              }, uploading ? "Uploading..." : "Save")
            ]),
          ]))
        ]),

          // Leaderboard
          e("div", { className: "leaderboard" }, [
            e("div", { className: "team-header" }, "Leaderboard"),
            ...leaderboard.map(entry =>
              e("div", { style: { color: entry.color }, key: entry.team }, `Team ${entry.team}: ${entry.score}`)
            )
          ]),
          e("br"),
          e("div", { style: { textAlign: "center", marginTop: "10px" } }, 
          e("div", null, `Start: ${formatDateTime(gameState?.start_time)}`),
          e(Countdown, { 
            start_time: gameState?.start_time, 
            end_time: gameState?.end_time 
          }),
          e("div", null, `End: ${formatDateTime(gameState?.end_time)}`)
        )
        ])

      ]);

    }

    function hexToRGBA(hex, alpha = 0.2) {
      let r = 0, g = 0, b = 0;
      if (hex.length === 7) {
        r = parseInt(hex.slice(1, 3), 16);
        g = parseInt(hex.slice(3, 5), 16);
        b = parseInt(hex.slice(5, 7), 16);
      } else if (hex.length === 4) {
        r = parseInt(hex[1] + hex[1], 16);
        g = parseInt(hex[2] + hex[2], 16);
        b = parseInt(hex[3] + hex[3], 16);
      }
      return `rgba(${r},${g},${b},${alpha})`;
    }

    ReactDOM.createRoot(document.getElementById("root")).render(e(App));
  </script>
</body>
</html>

